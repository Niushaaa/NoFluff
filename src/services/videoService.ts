import { VideoData, HighlightSegment, VideoTranscript, HighlightInterval } from '../types';
import { validateTranscript } from './transcriptService';

export interface VideoProcessingResult {
  videoData: VideoData;
  transcript: VideoTranscript;
  highlights: HighlightSegment[];
  highlightIntervals: HighlightInterval[];
  totalHighlightDuration: number;
}

export const processVideoUrl = async (
  url: string,
  onProgress?: (stage: string, progress: number, message: string) => void
): Promise<VideoProcessingResult> => {
  // OPTIMIZED FLOW WITH REAL-TIME PROGRESS:
  // 1. Validate YouTube URL and extract video ID
  // 2. Get video metadata (title, duration, thumbnail) 
  // 3. Process video (transcript + AI analysis) with progress updates
  // 4. Convert intervals to highlight segments for UI
  
  const videoId = extractVideoId(url);
  
  try {
    // Step 1: Process video with real-time progress updates
    const result = await processVideoBackend(videoId, onProgress);
    
    // Step 2: Create video metadata from processing result
    const videoData = {
      id: videoId,
      title: `Video ${videoId}`, // Could be enhanced with real title from YouTube API
      duration: result.transcript.totalDuration || 0,
      url: `https://youtube.com/watch?v=${videoId}`,
      thumbnailUrl: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`
    };
    
    // Step 3: Validate transcript
    if (!validateTranscript(result.transcript)) {
      throw new Error('Video transcript is not available or too short');
    }
    
    // Step 4: If no transcript duration, use sum of highlights as fallback
    if (!result.transcript.totalDuration) {
      const highlightDuration = result.highlightIntervals.reduce((sum, interval) => 
        sum + (interval.endTime - interval.startTime), 0);
      videoData.duration = highlightDuration; // Use highlight sum (could be 0)
    }
    
    // Step 5: Convert intervals to UI-friendly highlight segments
    const highlights = convertIntervalsToSegments(result.highlightIntervals);
    
    return {
      videoData,
      transcript: result.transcript,
      highlights,
      highlightIntervals: result.highlightIntervals,
      totalHighlightDuration: result.totalHighlightDuration
    };
  } catch (error) {
    throw new Error(`Failed to process video: ${error}`);
  }
};

export const extractVideoId = (url: string): string => {
  // TODO: Extract video ID from various YouTube URL formats
  // - youtube.com/watch?v=VIDEO_ID
  // - youtu.be/VIDEO_ID
  // - youtube.com/embed/VIDEO_ID
  const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/;
  const match = url.match(regex);
  
  if (!match || !match[1]) {
    throw new Error('Invalid YouTube URL');
  }
  
  return match[1];
};

// New combined backend processing function with real-time progress
const processVideoBackend = async (
  videoId: string, 
  onProgress?: (stage: string, progress: number, message: string) => void
): Promise<{
  transcript: VideoTranscript;
  highlightIntervals: HighlightInterval[];
  totalHighlightDuration: number;
}> => {
  return new Promise((resolve, reject) => {
    const eventSource = new EventSource(`http://localhost:3001/api/process/${videoId}`);
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (onProgress) {
          onProgress(data.stage, data.progress, data.message);
        }
      } catch (error) {
        console.error('Failed to parse progress data:', error);
      }
    };
    
    eventSource.addEventListener('complete', (event) => {
      try {
        const data = JSON.parse(event.data);
        eventSource.close();
        
        resolve({
          transcript: {
            segments: data.transcript.segments,
            language: data.transcript.language || 'en',
            isAutoGenerated: data.transcript.isAutoGenerated || false,
            totalDuration: data.transcript.totalDuration
          },
          highlightIntervals: data.highlights,
          totalHighlightDuration: data.totalHighlightDuration
        });
      } catch (error) {
        eventSource.close();
        reject(new Error('Failed to parse completion data'));
      }
    });
    
    eventSource.addEventListener('error', (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data);
        eventSource.close();
        reject(new Error(data.error || 'Processing failed'));
      } catch (error) {
        eventSource.close();
        reject(new Error('Video processing failed'));
      }
    });
    
    eventSource.onerror = (error) => {
      console.error('SSE connection error:', error);
      eventSource.close();
      reject(new Error('Connection to processing server failed'));
    };
  });
};


const convertIntervalsToSegments = (intervals: HighlightInterval[]): HighlightSegment[] => {
  return intervals.map((interval, index) => {
    // Use AI-provided name as title, with fallback
    const title = interval.name || generateSegmentTitle(interval.reason, index);
    const type = inferSegmentType(interval.reason);
    
    return {
      id: interval.id,
      title,
      startTime: interval.startTime,
      endTime: interval.endTime,
      type
    };
  });
};

const generateSegmentTitle = (reason: string, index: number): string => {
  if (!reason) return `Segment ${index + 1}`;
  
  // Extract meaningful concepts directly from AI reasoning
  const cleanReason = reason.replace(/^(This|It|The)\s+/i, '').trim();
  
  // If the reason is descriptive enough, use it directly as a title
  if (cleanReason.length > 5 && cleanReason.length < 50) {
    // Capitalize first letter and clean up
    const title = cleanReason.charAt(0).toUpperCase() + cleanReason.slice(1);
    // Remove trailing periods and clean up
    return title.replace(/\.$/, '').replace(/\s+/g, ' ');
  }
  
  const lowerReason = reason.toLowerCase();
  
  // Content-specific patterns for better titles
  if (lowerReason.includes('accountability') || lowerReason.includes('perception')) {
    return 'Accountability Discussion';
  } else if (lowerReason.includes('weather') || lowerReason.includes('forecast')) {
    return 'Weather Forecasting';
  } else if (lowerReason.includes('data') || lowerReason.includes('statistical') || lowerReason.includes('accuracy')) {
    return 'Data & Statistics';
  } else if (lowerReason.includes('reaction') || lowerReason.includes('angry') || lowerReason.includes('backlash')) {
    return 'Public Reaction';
  } else if (lowerReason.includes('example') || lowerReason.includes('concrete') || lowerReason.includes('evidence')) {
    return 'Real-World Example';
  } else if (lowerReason.includes('challenges') || lowerReason.includes('pressure') || lowerReason.includes('unique')) {
    return 'Key Challenges';
  } else if (lowerReason.includes('opening') || lowerReason.includes('stage') || lowerReason.includes('tone')) {
    return 'Opening Statement';
  } else if (lowerReason.includes('conclusion') || lowerReason.includes('reinforc') || lowerReason.includes('theme')) {
    return 'Main Conclusion';
  } else if (lowerReason.includes('insight') || lowerReason.includes('understanding') || lowerReason.includes('crucial')) {
    return 'Core Insight';
  } else {
    // Extract key noun from the reason
    const words = reason.split(' ');
    const importantWords = words.filter(word => {
      const w = word.toLowerCase().replace(/[^\w]/g, '');
      return w.length > 4 && !['this', 'that', 'with', 'from', 'about', 'which', 'where', 'their', 'being'].includes(w);
    });
    
    if (importantWords.length > 0) {
      const key = importantWords[0].replace(/[^\w]/g, '');
      return key.charAt(0).toUpperCase() + key.slice(1);
    }
    
    // Better fallback titles based on position
    const fallbackTitles = [
      'Opening Hook',
      'Key Point', 
      'Main Idea',
      'Important Detail',
      'Conclusion'
    ];
    return fallbackTitles[index] || `Segment ${index + 1}`;
  }
};

const inferSegmentType = (reason: string): 'hook' | 'explanation' | 'demo' | 'tip' | 'conclusion' => {
  // TODO: Infer segment type from AI analysis reason
  const lowerReason = reason.toLowerCase();
  
  if (lowerReason.includes('hook') || lowerReason.includes('introduction')) {
    return 'hook';
  } else if (lowerReason.includes('demonstration') || lowerReason.includes('example')) {
    return 'demo';
  } else if (lowerReason.includes('tip') || lowerReason.includes('advice')) {
    return 'tip';
  } else if (lowerReason.includes('conclusion') || lowerReason.includes('summary')) {
    return 'conclusion';
  } else {
    return 'explanation';
  }
};

